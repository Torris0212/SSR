import { WeakStorage } from "./types";
declare type WeakStorageCreator = () => WeakStorage;
export declare function weakMemoizeCreator(cacheCreator?: WeakStorageCreator, mapper?: (x: any, index: number) => any): <Arg extends object, T extends any[], Return>(func: (x: Arg, ...rest: T) => Return, cache?: WeakStorage) => (x: Arg, ...rest: T) => Return;
/**
 * weak memoization helper.
 * Uses the __first__ given argument to store result.
 *
 * `kache`'s API is equal to any other single-line memoization library except the requirement for
 * the first argument to be an object.
 *
 * ðŸ’¡ hint: sometimes it worth to move some arguments, put pick the "best one" to be the first
 *
 * @param {Object} argument0 - first argument has to be {object}, {array} or {function}
 * @param argument1 - any other, as well we any number or arguments
 *
 * @see https://github.com/theKashey/kashe#kashe
 * @example
 * // create a selector, which returns a new array using `array.filter` every time
 * const badSelector = (array) => array.filter(somehow)
 * // make it return the same object for the same array called.
 * const goodSelector = kashe(badSelector);
 */
export declare const kashe: <Arg extends object, T extends any[], Return>(func: (x: Arg, ...rest: T) => Return, cache?: WeakStorage) => (x: Arg, ...rest: T) => Return;
/**
 * a special version of {@link kashe} which does not strictly checks arg1+.
 * Could be used to bypass equality check, however use with caution
 *
 * @see https://github.com/theKashey/kashe#weakkashe
 * @example
 * const weakMap = weakKashe((data, iterator, ...deps) => data.map(iterator));
 * const derived = weakMap(data, line => ({...line, somethingElse}), localVariable1);
 * // ðŸ‘† second argument is changing every time, but as long as it's __String representation__ is the same - result is unchanged.
 */
export declare const weakKashe: <Arg extends object, T extends any[], Return>(func: (x: Arg, ...rest: T) => Return, cache?: WeakStorage) => (x: Arg, ...rest: T) => Return;
export declare function swap<T, K, R>(fn: (t: T, k: K) => R): (k: K, T: T) => R;
declare type BoxedCall<T extends any[], K> = (state: object, ...rest: T) => K;
/**
 * Prepends a single function with an additional argument, which would be used as a "box" key layer.
 * Literally "puts function in a box"
 *
 * @param {Function} fn - function to "box"
 *
 * @see https://github.com/theKashey/kashe#boxed
 * @see {@link inboxed} - for nested caches.
 *
 * @example
 * const addTwo = (a,b) => a+b; // could not be "kashe" memoized
 * const bAddTwo = boxed(addTwo); // "box" it
 * const cacheKey = {}; // any object
 * // ðŸ‘‡ not function takes 3 arguments
 * bAddTwo(cacheKey, 1, 2) === bAddTwo(cacheKey, 1, 2) === 3
 * // result is "stored in a first argument" - using another key equivalent to cache clear.
 * bAddTwo(otherCacheKey, 1, 2) // -> a new call
 */
export declare function boxed<T extends any[], K>(fn: (...args: T) => K): BoxedCall<T, K>;
/**
 * Prepends with additional cache-key, which will be used for any other {@link kashe} call made inside.
 * inboxed scopes all the nested caches behind a first argument, creating a "sub cache".
 *
 * inboxed is about __isolation__. Or creating parallel caches.
 *
 * @param {Function} fn function to "box"
 *
 * @see {@link boxed} for non-nested caches.
 * @see https://github.com/theKashey/kashe#inboxed
 * @example
 * const kashedSelector = kashe((state) => ({state, counter: counter++})); // returns unique object every all
 * const inboxedSelector = inboxed(kashedSelector);
 *
 * âœ… kashedSelector(state) === kashedSelector(state)
 * const cacheKey = {}; // any object
 * ðŸ‘‰ inboxedSelector(cacheKey, state) === inboxedSelector(cacheKey, state)
 * âœ… inboxedSelector({}, state) !== inboxedSelector({}, state)
 */
export declare function inboxed<T extends any[], K>(fn: (...args: T) => K): BoxedCall<T, K>;
/**
 * Creates a clone of a kash-ed function with another internal cache.
 * Useful for isolation one kashe call from another
 * @param fn - function to memoize
 * @param [options]
 * @param [options.singleton=false] force single variant for all internal cache calls
 *
 * @see {@link inboxed} for argument based cache separation
 * @see https://github.com/theKashey/kashe#fork
 */
export declare function fork<T extends any[], K>(fn: (...args: T) => K, options?: {
    singleton?: boolean;
}): (...args: T) => K;
export {};
