"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fork = exports.inboxed = exports.boxed = exports.swap = exports.weakKashe = exports.kashe = exports.weakMemoizeCreator = void 0;
var function_double_1 = require("function-double");
var weakStorage_1 = require("./weakStorage");
var cacheStack = [];
var cacheOverride;
var pushCache = function (cache) {
    cacheStack.push(cache);
    cacheOverride = cache;
};
var popCache = function (cache) {
    var popped = cacheStack.pop();
    if (cache !== popped) {
        console.error({
            expected: cache,
            given: popped,
            stack: cacheStack,
        });
        throw new Error('kashe synchronization failed');
    }
    cacheOverride = cacheStack[cacheStack.length - 1];
};
var addKashePrefix = function (name) { return "kashe-" + name; };
var getCacheFor = function (fn, cacheCreator) {
    if (!cacheOverride) {
        return;
    }
    var cache = cacheOverride.get([fn]);
    if (cache) {
        return cache.value;
    }
    return cacheOverride.set([fn], cacheCreator());
};
function weakMemoizeCreator(cacheCreator, mapper) {
    if (cacheCreator === void 0) { cacheCreator = weakStorage_1.createWeakStorage; }
    /**
     * memoizes a function
     */
    return function kashe(func, cache) {
        if (cache === void 0) { cache = cacheCreator(); }
        var _this_ = { func: func };
        return function_double_1.default(function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var localCache = getCacheFor(_this_, cacheCreator) || cache;
            var usedArgs = mapper ? args.map(mapper) : args;
            var test = localCache.get(usedArgs);
            if (test) {
                return test.value;
            }
            return localCache.set(usedArgs, 
            // @ts-ignore
            func.apply(void 0, args));
        }, func, { name: addKashePrefix });
    };
}
exports.weakMemoizeCreator = weakMemoizeCreator;
/**
 * weak memoization helper.
 * Uses the __first__ given argument to store result.
 *
 * `kache`'s API is equal to any other single-line memoization library except the requirement for
 * the first argument to be an object.
 *
 * ðŸ’¡ hint: sometimes it worth to move some arguments, put pick the "best one" to be the first
 *
 * @param {Object} argument0 - first argument has to be {object}, {array} or {function}
 * @param argument1 - any other, as well we any number or arguments
 *
 * @see https://github.com/theKashey/kashe#kashe
 * @example
 * // create a selector, which returns a new array using `array.filter` every time
 * const badSelector = (array) => array.filter(somehow)
 * // make it return the same object for the same array called.
 * const goodSelector = kashe(badSelector);
 */
exports.kashe = weakMemoizeCreator(weakStorage_1.createWeakStorage);
/**
 * a special version of {@link kashe} which does not strictly checks arg1+.
 * Could be used to bypass equality check, however use with caution
 *
 * @see https://github.com/theKashey/kashe#weakkashe
 * @example
 * const weakMap = weakKashe((data, iterator, ...deps) => data.map(iterator));
 * const derived = weakMap(data, line => ({...line, somethingElse}), localVariable1);
 * // ðŸ‘† second argument is changing every time, but as long as it's __String representation__ is the same - result is unchanged.
 */
exports.weakKashe = weakMemoizeCreator(weakStorage_1.createWeakStorage, function (arg, i) { return i > 0 ? String(arg) : arg; });
function weakKasheFactory(func, indexId) {
    if (indexId === void 0) { indexId = 0; }
    var cache = weakStorage_1.createWeakStorage();
    return function kasheFactory() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var localCache = cacheOverride || cache;
        var cacheArg = [args[indexId]];
        var test = localCache.get(cacheArg);
        if (test) {
            return test.value;
        }
        return localCache.set(cacheArg, 
        // @ts-ignore
        func.apply(void 0, args));
    };
}
function swap(fn) {
    return function (k, t) { return fn(t, k); };
}
exports.swap = swap;
/**
 * Prepends a single function with an additional argument, which would be used as a "box" key layer.
 * Literally "puts function in a box"
 *
 * @param {Function} fn - function to "box"
 *
 * @see https://github.com/theKashey/kashe#boxed
 * @see {@link inboxed} - for nested caches.
 *
 * @example
 * const addTwo = (a,b) => a+b; // could not be "kashe" memoized
 * const bAddTwo = boxed(addTwo); // "box" it
 * const cacheKey = {}; // any object
 * // ðŸ‘‡ not function takes 3 arguments
 * bAddTwo(cacheKey, 1, 2) === bAddTwo(cacheKey, 1, 2) === 3
 * // result is "stored in a first argument" - using another key equivalent to cache clear.
 * bAddTwo(otherCacheKey, 1, 2) // -> a new call
 */
function boxed(fn) {
    return exports.kashe(function (_) {
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            rest[_i - 1] = arguments[_i];
        }
        return fn.apply(void 0, rest);
    });
}
exports.boxed = boxed;
var localCacheCreator = exports.kashe(function (_) { return weakStorage_1.createWeakStorage(); });
/**
 * Prepends with additional cache-key, which will be used for any other {@link kashe} call made inside.
 * inboxed scopes all the nested caches behind a first argument, creating a "sub cache".
 *
 * inboxed is about __isolation__. Or creating parallel caches.
 *
 * @param {Function} fn function to "box"
 *
 * @see {@link boxed} for non-nested caches.
 * @see https://github.com/theKashey/kashe#inboxed
 * @example
 * const kashedSelector = kashe((state) => ({state, counter: counter++})); // returns unique object every all
 * const inboxedSelector = inboxed(kashedSelector);
 *
 * âœ… kashedSelector(state) === kashedSelector(state)
 * const cacheKey = {}; // any object
 * ðŸ‘‰ inboxedSelector(cacheKey, state) === inboxedSelector(cacheKey, state)
 * âœ… inboxedSelector({}, state) !== inboxedSelector({}, state)
 */
function inboxed(fn) {
    var factory = weakKasheFactory(function (cacheVariation) {
        var cache = localCacheCreator(cacheVariation);
        return function () {
            var rest = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                rest[_i] = arguments[_i];
            }
            try {
                pushCache(cache);
                return fn.apply(void 0, rest);
            }
            finally {
                popCache(cache);
            }
        };
    });
    return function (_) {
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            rest[_i - 1] = arguments[_i];
        }
        return factory(_).apply(void 0, rest);
    };
}
exports.inboxed = inboxed;
/**
 * Creates a clone of a kash-ed function with another internal cache.
 * Useful for isolation one kashe call from another
 * @param fn - function to memoize
 * @param [options]
 * @param [options.singleton=false] force single variant for all internal cache calls
 *
 * @see {@link inboxed} for argument based cache separation
 * @see https://github.com/theKashey/kashe#fork
 */
function fork(fn, options) {
    var cache = localCacheCreator({});
    var genLocalCache = function () { return localCacheCreator({}); };
    return function () {
        var rest = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            rest[_i] = arguments[_i];
        }
        var cacheOverride = ((!options || !options.singleton) ? getCacheFor(cache, genLocalCache) : null) || cache;
        try {
            pushCache(cacheOverride);
            return fn.apply(void 0, rest);
        }
        finally {
            popCache(cacheOverride);
        }
    };
}
exports.fork = fork;
