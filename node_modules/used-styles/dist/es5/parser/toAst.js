"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildAst = void 0;
var tslib_1 = require("tslib");
var crc32 = (0, tslib_1.__importStar)(require("crc-32"));
var postcss = (0, tslib_1.__importStar)(require("postcss"));
var ranges_1 = require("./ranges");
var utils_1 = require("./utils");
var getAtRule = function (rule) {
    if (rule && rule.parent && 'name' in rule.parent && rule.parent.name === 'media') {
        return getAtRule(rule.parent).concat(rule.parent.params);
    }
    return [];
};
var getBreak = function (rule) {
    var breakPoints = [
        rule.indexOf(' '),
        rule.indexOf('>'),
        rule.indexOf('~'),
        rule.indexOf('+'),
        rule.indexOf(':'),
    ].filter(function (index) { return index > 0; });
    if (breakPoints.length === 0) {
        return rule.length;
    }
    var min = Math.min.apply(Math, breakPoints);
    return min ? min : rule.length;
};
var getPostfix = function (rule) {
    return rule.substr(getBreak(rule)).trim();
};
var bodyCounter = 1;
var assignBody = function (decl, bodies) {
    var d = Object.values(bodies).find(function (bodyDecl) { return (0, ranges_1.rangesIntervalEqual)(bodyDecl, decl); });
    if (d) {
        return d;
    }
    decl.id = bodyCounter++;
    bodies[decl.id] = decl;
    return decl;
};
var hashString = function (str) {
    return crc32.str(str).toString(32);
};
var hashBody = function (body) {
    return hashString(JSON.stringify(body.rules));
};
var buildAst = function (CSS, file) {
    if (file === void 0) { file = ''; }
    var root = postcss.parse(CSS);
    var selectors = [];
    var atRules = [];
    var bodies = {};
    var atParents = new Set();
    root.walkAtRules(function (rule) {
        if (rule.name === 'charset') {
            return;
        }
        if (rule.name !== 'media') {
            atParents.add(rule);
            atRules
                .push({
                kind: rule.name,
                id: rule.params,
                css: rule.toString(),
            });
        }
    });
    root.walkRules(function (rule) {
        if (atParents.has(rule.parent)) {
            return;
        }
        var ruleSelectors = rule.selector.split(',');
        ruleSelectors
            .map(function (sel) { return sel.trim(); })
            .forEach(function (selector) {
            var stand = {
                media: getAtRule(rule),
                selector: selector,
                pieces: (0, utils_1.mapSelector)(selector),
                postfix: getPostfix(selector),
                declaration: 0,
                hash: selector,
            };
            var parents = (0, utils_1.extractParents)(selector);
            if (parents.length > 0) {
                stand.parents = parents;
            }
            var delc = {
                id: NaN,
                rules: [],
                start: (0, ranges_1.createRange)(Infinity, Infinity),
                end: (0, ranges_1.createRange)(0, 0),
            };
            rule.walkDecls(function (_a) {
                var prop = _a.prop, value = _a.value, source = _a.source, important = _a.important;
                if (source) {
                    delc.start = (0, ranges_1.localRangeMin)(delc.start, source.start);
                    delc.end = (0, ranges_1.localRangeMax)(delc.end, source.end);
                    delc.rules.push({
                        prop: prop,
                        value: value,
                        important: important,
                    });
                }
            });
            stand.declaration = assignBody(delc, bodies).id;
            stand.hash = "" + selector + hashBody(delc) + hashString(stand.postfix) + hashString(stand.media.join());
            selectors.push(stand);
        });
    });
    return {
        file: file,
        selectors: selectors,
        bodies: bodies,
        atRules: atRules,
    };
};
exports.buildAst = buildAst;
