import * as crc32 from 'crc-32';
import * as postcss from 'postcss';
import { createRange, localRangeMax, localRangeMin, rangesIntervalEqual } from './ranges';
import { extractParents, mapSelector } from './utils';
var getAtRule = function (rule) {
    if (rule && rule.parent && 'name' in rule.parent && rule.parent.name === 'media') {
        return getAtRule(rule.parent).concat(rule.parent.params);
    }
    return [];
};
var getBreak = function (rule) {
    var breakPoints = [
        rule.indexOf(' '),
        rule.indexOf('>'),
        rule.indexOf('~'),
        rule.indexOf('+'),
        rule.indexOf(':'),
    ].filter(function (index) { return index > 0; });
    if (breakPoints.length === 0) {
        return rule.length;
    }
    var min = Math.min.apply(Math, breakPoints);
    return min ? min : rule.length;
};
var getPostfix = function (rule) {
    return rule.substr(getBreak(rule)).trim();
};
var bodyCounter = 1;
var assignBody = function (decl, bodies) {
    var d = Object.values(bodies).find(function (bodyDecl) { return rangesIntervalEqual(bodyDecl, decl); });
    if (d) {
        return d;
    }
    decl.id = bodyCounter++;
    bodies[decl.id] = decl;
    return decl;
};
var hashString = function (str) {
    return crc32.str(str).toString(32);
};
var hashBody = function (body) {
    return hashString(JSON.stringify(body.rules));
};
export var buildAst = function (CSS, file) {
    if (file === void 0) { file = ''; }
    var root = postcss.parse(CSS);
    var selectors = [];
    var atRules = [];
    var bodies = {};
    var atParents = new Set();
    root.walkAtRules(function (rule) {
        if (rule.name === 'charset') {
            return;
        }
        if (rule.name !== 'media') {
            atParents.add(rule);
            atRules
                .push({
                kind: rule.name,
                id: rule.params,
                css: rule.toString(),
            });
        }
    });
    root.walkRules(function (rule) {
        if (atParents.has(rule.parent)) {
            return;
        }
        var ruleSelectors = rule.selector.split(',');
        ruleSelectors
            .map(function (sel) { return sel.trim(); })
            .forEach(function (selector) {
            var stand = {
                media: getAtRule(rule),
                selector: selector,
                pieces: mapSelector(selector),
                postfix: getPostfix(selector),
                declaration: 0,
                hash: selector,
            };
            var parents = extractParents(selector);
            if (parents.length > 0) {
                stand.parents = parents;
            }
            var delc = {
                id: NaN,
                rules: [],
                start: createRange(Infinity, Infinity),
                end: createRange(0, 0),
            };
            rule.walkDecls(function (_a) {
                var prop = _a.prop, value = _a.value, source = _a.source, important = _a.important;
                if (source) {
                    delc.start = localRangeMin(delc.start, source.start);
                    delc.end = localRangeMax(delc.end, source.end);
                    delc.rules.push({
                        prop: prop,
                        value: value,
                        important: important,
                    });
                }
            });
            stand.declaration = assignBody(delc, bodies).id;
            stand.hash = "" + selector + hashBody(delc) + hashString(stand.postfix) + hashString(stand.media.join());
            selectors.push(stand);
        });
    });
    return {
        file: file,
        selectors: selectors,
        bodies: bodies,
        atRules: atRules,
    };
};
